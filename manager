#!/home/dormierian/Games/rimworld/instance_manager/bin/python

import os, click, humanize, regex, csv, time

from InquirerPy import inquirer
from InquirerPy.base.control import Choice
from InquirerPy.separator import Separator

from colorama import Fore, Back, Style

from datetime import datetime
# from sheet_manager import get_modlist_info, get_instances, get_slow_mods, push_to_backend, copy_instance_sheet
from helpers import *
import mod_handler, statter, rentry, sorter, sheet_manager

os.chdir("/home/dormierian/Games/rimworld/instance_manager")

@click.group
def cli():
    pass

def modlist_sheet_grab(instance,fetch=None):
    if fetch is None:
        fetch = click.confirm("Get modlist from sheet?")
    if fetch:
        with open(f"instances/{instance}/modlist.csv","w") as instance_csv:
            instance_csv.write(sheet_manager.get_modlist_info(instance))

def prompt_instance_name():
    instance_name = ""
    if os.path.exists(f"cached_instance_name"):
        with open(f"cached_instance_name","r") as instance_cache:
                cached_instance_name = instance_cache.readlines()[0]
        if click.confirm(f"Use cached instance {cached_instance_name}?"):
            instance_name = cached_instance_name
            print(f"Using cached instance {instance_name}")
    if not instance_name:
        with open(f"cached_instance_name","w") as instance_cache:            
            instance_name = inquirer.select(
                message="Choose instance",
                choices=sheet_manager.get_instances(),
                pointer=">",
            ).execute()

            instance_cache.write(instance_name)
    return instance_name

@cli.command
def modlist():
    instance_name = prompt_instance_name()    
    modlist_sheet_grab(instance_name)
    mod_handler.generate_modlist(instance_name)

@cli.command("update")
def cli_update():
    modd = statter.mod_metadata()
    toUpdate = []

    for mod in modd:
        if modd[mod]["source"] == "STEAM":
            timeDownloaded = modd[mod]["time_downloaded"]
            timeUpdated = modd[mod]["time_updated"]
            if timeDownloaded < timeUpdated:
                toUpdate.append(mod)

    if toUpdate:
        print(f"The following {len(toUpdate)} mods are out of date:")
        print("\n".join([modd[mod]["graphical_name"] for mod in toUpdate]))

        if click.confirm("Download them now?"):
            mod_handler.downloadMods(toUpdate)
    else:
        print("No mods detected out of date.")

@cli.command("stats")
@click.argument("choice",nargs = -1)    
def cli_mods_stats(choice):
    options = ["authors","subscribers","size","time","dependencies"]

    if len(choice) > 1:
        print("Please pass 0 or 1 choice")
        return
    elif len(choice) == 0:
        choice = inquirer.select(
            message="Get mods by",
            choices=options,
            pointer=">",
        ).execute()
    else:
        choice = choice[0]
        if choice not in options:
            print("Option not valid")
            return
    
    if choice == "authors":
        modd = statter.mod_metadata(fetch=False)
        authors = {}
        for d in modd:
            if modd[d]["author"]:
                # Split authors by commas, strip whitespace, and increment mod count for each author

                for author in [x.lstrip() for x in modd[d]["author"].split(",")]:
                    if author in authors:
                        authors[author].append(d)
                    else:
                        authors[author] = [d]

        # Sort authors by the number of mods they made (descending order)
        authors = {k: v for k, v in sorted(authors.items(), key=lambda item: len(item[1]), reverse=True)}

        # Print the sorted list of authors with mod counts
        choices = [Choice(value=author,name=f"{author}: {len(authors[author])} mods") for author in authors]
        author = inquirer.select(
            message="Choose author",
            choices=choices,
            pointer=">",
        ).execute()

        print("\n".join([modd[mod]["graphical_name"] for mod in authors[author]]))
    elif choice == "dependencies":
        modd = statter.mod_metadata(include_ludeon=True,fetch=False)
        deps = {}
        
        for d in modd:
            if modd[d]["deps"]:
                for dep in modd[d]["deps"]:
                    if dep in deps:
                        deps[dep].append(d)
                    else:
                        deps[dep] = [d]

        # Sort authors by the number of mods they made (descending order)
        deps = {k: v for k, v in sorted(deps.items(), key=lambda item: len(item[1]), reverse=True)}

        modd_by_pid = {modd[x]["pid"]: modd[x] for x in modd}

        # Print the sorted list of authors with mod counts
        choices = [Choice(value=dep,name=f"{modd_by_pid[dep]["name"] if dep in modd_by_pid else dep} has {len(deps[dep])} dependencies") for dep in deps]

        dep = inquirer.select(
            message="Select mod to get dependencies of",
            choices=choices,
            pointer=">",
        ).execute()

        print("\n".join(
            [modd[dep]["graphical_name"] for dep in deps[dep]]
        ))
        
    elif choice == "subscribers":
        data = statter.mod_metadata(sort_by="subs",fetch=False)
        print("".join([f"{data[mod]['graphical_name']} has {data[mod]['subs']} subscribers \n" for mod in data]))
    elif choice == "size":
        modd = statter.mod_metadata(sort_by="size",fetch=False)
        print("".join([f"{modd[mod]["graphical_name"]} is {humanize.naturalsize(data[mod]["size"], binary=True)} \n" for mod in modd]))
    elif choice == "time":
        modd = statter.mod_metadata(sort_by="time_created",fetch=False)
        print("".join([f"{modd[mod]["graphical_name"]} was made at {datetime.fromtimestamp(int(modd[mod]["time_created"])/1000).strftime('%Y-%m-%d %H:%M:%S')}\n" for mod in modd]))

@cli.command("rentry")
def reentry_manager():
    options = ["Generate","Load","Compare","Check for Slow Mods"]

    choice = inquirer.select(
            message="Get mods by",
            choices=options,
            pointer=">",
        ).execute().lower()

    if choice == "load":
        url = click.prompt("Rentry Url?")
        ren = rentry.import_rentry(url)

        modd = statter.mod_metadata(index_by="pid",include_ludeon=True)
        notin = [x for x in ren if x not in modd]
        print("\n Missing Mod: ".join(notin))
    elif choice == "compare":
        url = click.prompt("Rentry Url?")
        ren = rentry.import_rentry(url)

        modd = statter.mod_metadata(index_by="pid",include_ludeon=True,prune_by=sheet_manager.get_modlist_info(prompt_instance_name()))
        yesin = [modd[x]["name"] for x in ren if x in modd]
        print("\n".join(yesin))     
    elif choice == "generate":
        instance_name = prompt_instance_name()
        mods = mod_handler.get_id_list(instance_name)
        modd = statter.mod_metadata(prune_by=mods,index_by="pid",include_ludeon=True)
        
        i = 0
        for mod in sorter.sorter(mods):
            i+=1
            modd[mod]["sort"] = i
        start_time = time.time()
        ren = rentry.compile_rentry(modd)
        print(f"{Style.DIM}Generated rentry for {i} mods in {time.time()-start_time}{Style.RESET_ALL}")

        start_time = time.time()
        rentry.upload(ren)
        print(f"{Style.DIM}Uploaded in {time.time()-start_time}{Style.RESET_ALL}")

    elif choice == "check for slow mods":
        url = click.prompt("Rentry Url?")
        modlist = rentry.import_rentry(url)
        slow_mods = sheet_manager.get_slow_mods()

        print([x for x in modlist if x in slow_mods])

@cli.command("encode")
def encode():
    mod_handler.dds_encode("source_mods")

@cli.command("modd")
def modd():
    statter.mod_metadata()

@cli.command("sheet_push")
def sheet_push(instance_name=None):
    if not instance_name:
        instance_name = prompt_instance_name()
    instance = mod_handler.get_id_list(instance_name)
    modd = statter.mod_metadata(sort_by="time_first_downloaded") 
    sheet_manager.push_to_backend(modd,instance,instance_name)

@cli.command("time")
def whenlastupdated():
    time = click.prompt("Time to set (unix milis)")
    mod_handler.set_download_time(statter.source_mods_list(steam_only=True),time)

@cli.command("sort")
def cli_sort_modlist():
    sorter.sorter(mod_handler.get_id_list(prompt_instance_name()))

@cli.command("add_mods")
def cli_add_mods():
    modd = statter.mod_metadata()
    to_add = []
    print("Write done to stop")
    while True:
        workshop = click.prompt("Steam Workshop URL?").lower()
        if workshop == "done":
            break
        if workshop == "undo":
            print(f"Removed workshop item {to_add[-1]}")
            del to_add[-1]
            continue
        
        id_match = regex.search(r"(?<=\?id=)([0-9]*)",workshop)
        if id_match:
            mod_id = id_match.group()
        else:
            print("Couldn't get id, try again")
            continue

        if mod_id in modd or mod_id in to_add:
            print(f"Mod {mod_id} already downloaded")
            continue
        else:
            print(f"Added mod {mod_id} to list")

        to_add.append(mod_id)
    modd = mod_handler.downloadMods(to_add, regen_mods=True)

    if click.confirm("Add fresh mods to instance?"):
        instance_name = prompt_instance_name()
        with open(f"instances/{instance_name}/modlist.csv","r") as instance_csv:
            reader = csv.reader(instance_csv)
            for row in reader:
                mods=row
        mods.extend(to_add)
        with open(f"instances/{instance_name}/modlist.csv","w") as instance_csv:
            instance_csv.write(",".join(mods))
        sheet_manager.push_to_backend(modd,mods,instance_name)
    mods = []
    
    return mods

@cli.command("mkinstance")
def cli_make_instance():
    instance_name = click.prompt("What do you want to name the instance?")

    if click.confirm("Copy existing instance?"):
        source = prompt_instance_name()
    else:
        source = "Instance Template"
    
    if sheet_manager.copy_instance_sheet(source,instance_name):
        print("Sheet copied")
    else:
        print("Sheet already exists!")
    
    os.mkdir("instances/"+instance_name)

    with open(f"instances/{instance_name}/modlist.csv","w") as f:
        f.write(sheet_manager.get_modlist_info(instance_name))   

@cli.command("inscon")
@click.argument("instance",nargs = -1)
def cli_manage_instance(instance):
    if len(instance) > 1:
        print("Please pass 0 or 1 instance")
        return
    elif len(instance) == 0:
        instance = prompt_instance_name()
    else:
        instance = instance[0]
    
    modd = statter.mod_metadata(sort_by="time_first_downloaded")

    modlist_sheet_grab(instance)
    instance_list = mod_handler.get_id_list(instance)

    choices = [
        Choice(name=modd[d]["name"],value=d,enabled=d in instance_list) 
        for d in modd
    ]

    response = inquirer.select(
        message="Select which mods to toggle",
        choices=choices,
        pointer=">",
        multiselect=True
    ).execute()

    to_enable = [mod for mod in response if mod not in instance_list]
    print(to_enable)

    to_disable = [mod for mod in instance_list if mod not in response]
    print(to_disable)

if __name__ == '__main__':
    cli()
