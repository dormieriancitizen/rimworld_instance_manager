#!/home/dormierian/Games/rimworld/instance_manager/bin/python

import csv, os, click, time, humanize # type: ignore
from colors import color
from InquirerPy import inquirer

from datetime import datetime
from sheet_manager import get_modlist_info, get_instances, set_sorder
from helpers import *
import mod_parser, statter, rentry

os.chdir(os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__))))

@click.group
def cli():
    pass

def downloadMods(mods):
    # Pass list of ids
    os.system(f"/home/dormierian/Games/rimworld/SteamCMD/steamcmd.sh +logon anonymous +workshop_download_item 294100 {" +workshop_download_item 294100 ".join(mods)} +exit")
    setDownloadTime(mods)

    if click.confirm("\nDDS-encode downloaded mods?"):
        ddsEncode()

@cli.command
def modlist():
    instance_name = promptInstanceName()    

    sheetGotten = False
    if click.confirm("Get modlist from sheet?"):
        sheetGotten = True
        with open(f"instances/{instance_name}/modlist.csv","w") as instance_csv:
            instance_csv.write(get_modlist_info(instance_name))

    generateModList(instance_name)

    if sheetGotten:
        if click.confirm("Set new sort order on sheet?"):
            load_sorder_to_sheet(instance_name)

def promptInstanceName():
    instance_name = ""
    if os.path.exists(f"cached_instance_name"):
        if click.confirm("Use cached instance?"):
            with open(f"cached_instance_name","r") as instance_cache:
                instance_name = instance_cache.readlines()[0]
            print(f"Using cached instance {instance_name}")
    if not instance_name:
        with open(f"cached_instance_name","w") as instance_cache:            
            instance_name = inquirer.select(
                message="Choose instance",
                choices=get_instances(),
                pointer=">",
            ).execute()

            instance_cache.write(instance_name)
    return instance_name

def getIdList(instance):
    mods = []

    with open(f"instances/{instance}/modlist.csv","r") as instance_csv:
        reader = csv.reader(instance_csv)
        for row in reader:
            mods=row
    
    return mods


def generateModList(instance):
    mods = getIdList(instance)

    print("Clearing active mod folder")
    removeFolder("active/mods")
    source_mods  = statter.source_mods_list()
    # print(source_mods)

    missing_mod_list = []

    for mod in mods:
        if mod in source_mods:
            continue
        else:
            print(f"Missing Mod: {mod}")
            missing_mod_list.append(mod)
    
    if missing_mod_list:
        if click.confirm("Missing mods detected. Try to download?"):
            downloadMods(missing_mod_list)
        generateModList(instance)
    else:
        for mod in mods:
            try:
                if mod in source_mods:
                    os.symlink(os.path.abspath(f"source_mods/{mod}"),f"active/mods/{mod}")
                else:
                    print(f"Missing Mod. Download failed?: {mod}")
            except FileExistsError:
                print(f"Duplicate Mod: {mod}")
        if click.confirm("Run RimPy?"):
            os.chdir("../rimpy/")
            os.system("./rimpy")

def setDownloadTime(mods, write_time=None):
    if not write_time:
        write_time = str(time.time() * 1000)

    for mod in mods:
        if not os.path.exists(f"source_mods/{mod}/timeDownloaded"):
            open(f"source_mods/{mod}/timeDownloaded","x")
        with open(f"source_mods/{mod}/timeDownloaded",'w') as dateFile:
            dateFile.write(write_time)

@cli.command("update")
def updateMods():
    modd = statter.mod_metadata()
    toUpdate = []

    for mod in modd:
        if modd[mod]["source"] == "STEAM":
            timeDownloaded = modd[mod]["time_downloaded"]
            timeUpdated = modd[mod]["time_updated"]
            if timeDownloaded < timeUpdated:
                toUpdate.append(mod)

    if toUpdate:
        print(f"The following {len(toUpdate)} mods are out of date:")
        print("\n".join([modd[mod]["name"] for mod in toUpdate]))

        if click.confirm("Download them now?"):
            downloadMods(toUpdate)
    else:
        print("No mods detected out of date.")

@cli.command("stats")
def getModStats():
    options = ["authors","subscribers","size","time","dependencies"]

    choice = inquirer.select(
        message="Get mods by",
        choices=options,
        pointer="-",
    ).execute()

    if choice == "authors":
        modd = statter.mod_metadata()

        authors = {}
        for d in modd:
            if modd[d]["author"]:
                # Split authors by commas, strip whitespace, and increment mod count for each author

                for author in [x.lstrip() for x in modd[d]["author"].split(",")]:
                    if author in authors:
                        authors[author].append(d)
                    else:
                        authors[author] = [d]

        # Sort authors by the number of mods they made (descending order)
        authors = {k: v for k, v in sorted(authors.items(), key=lambda item: len(item[1]), reverse=True)}

        # Print the sorted list of authors with mod counts
        modStrings = {f"{author}: {len(authors[author])} mods": author for author in authors}

        author = inquirer.select(
            message="Choose author",
            choices=modStrings,
            pointer=">",
        ).execute()

        author = modStrings[author]

        print("\n".join([modd[mod]["name"] for mod in authors[author]]))

    elif choice == "dependencies":
        modd = statter.mod_metadata()
        deps = {}

        for d in modd:
            if modd[d]["deps"]:
                # Split authors by commas, strip whitespace, and increment mod count for each author
                for dep in modd[d]["deps"]:
                    if dep in deps:
                        deps[dep].append(d)
                    else:
                        deps[dep] = [d]

        # Sort authors by the number of mods they made (descending order)
        deps = {k: v for k, v in sorted(deps.items(), key=lambda item: len(item[1]), reverse=True)}

        modd_by_pid = {modd[x]["pid"]: modd[x] for x in modd}

        # Print the sorted list of authors with mod counts
        modStrings = {f"{modd_by_pid[dep]["name"] if dep in modd_by_pid else dep}: {len(deps[dep])} mods": dep for dep in deps}

        dep = inquirer.select(
            message="Select mod to get dependencies of",
            choices=modStrings,
            pointer=">",
        ).execute()

        dep = modStrings[dep]

        print("\n".join(
            [modd[dep]["name"] for dep in deps[dep]]
        ))
        
    elif choice == "subscribers":
        data = statter.sort_modds_by(statter.mod_metadata(),"subs")
        out = ""
        for mod in data:
            out+=f"{data[mod]["name"]} has {data[mod]["subs"]} subscribers \n"
        print(out)
    elif choice == "size":
        data = statter.sort_modds_by(statter.mod_metadata(),"size")
        out = ""
        for mod in data:
            out+=f"{data[mod]["name"]} is {humanize.naturalsize(data[mod]["size"], binary=True)} \n"
        print(out)
    elif choice == "time":
        data = statter.sort_modds_by(statter.mod_metadata(),"time_created")
        out = ""
        for mod in data:
            out+=f"{data[mod]["name"]} was made at {datetime.fromtimestamp(int(data[mod]["time_created"])).strftime('%Y-%m-%d %H:%M:%S')}\n"
        print(out)
    return

@cli.command("rentry")
def reentry_manager():
    options = ["Generate","Load"]

    choice = inquirer.select(
            message="Get mods by",
            choices=options,
            pointer=">",
        ).execute()

    if choice == "Load":
        url = click.prompt("Rentry Url?")
        print(rentry.import_rentry(url))
        print(statter.source_mods_list()).values()
    elif choice == "Generate":
        instance_name = promptInstanceName()
        mods = getIdList(instance_name)
        ren = rentry.compile_rentry(mods,statter.mod_metadata())
        rentry.upload(ren)

@cli.command("encode")
def encode():
    ddsEncode()

def ddsEncode():
    os.system("./todds -f BC1 -af BC7 -on -vf -fs -r Textures -t -p source_mods")

@cli.command("sorder")
def ui_sorder():
    load_sorder_to_sheet(promptInstanceName())

def load_sorder_to_sheet(instance_name):
    sorder = statter.load_sort_order(getIdList(instance_name))

    set_sorder(sorder,instance_name)

@cli.command("modd")
def modd():
    statter.mod_metadata()

@cli.command
def whenlastupdated():
    time = click.prompt("Time to set (unix milis)")
    setDownloadTime(statter.source_mods_list(steam_only=True),time)

if __name__ == '__main__':
    cli()
