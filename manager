#!/home/dormierian/Games/rimworld/instance_manager/bin/python

import csv, os, click, time, humanize # type: ignore
from colors import color
from InquirerPy import inquirer

from datetime import datetime
from sheet_manager import get_modlist_info, get_instances, set_sorder
from helpers import *
import mod_parser, statter, rentry

os.chdir(os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__))))

@click.group
def cli():
    pass

def downloadMods(mods):
    # Pass list of ids
    os.system(f"/home/dormierian/Games/rimworld/SteamCMD/steamcmd.sh +logon anonymous +workshop_download_item 294100 {" +workshop_download_item 294100 ".join(mods)} +exit")
    setDownloadTime(mods)

    if click.confirm("\nDDS-encode downloaded mods?"):
        ddsEncode()

@cli.command
def modlist():
    instance_name = promptInstanceName()    

    sheetGotten = False
    if click.confirm("Get modlist from sheet?"):
        sheetGotten = True
        with open(f"instances/{instance_name}/modlist.csv","w") as instance_csv:
            instance_csv.write(get_modlist_info(instance_name))

    generateModList(instance_name)

    if sheetGotten:
        if click.confirm("Set new sort order on sheet?"):
            load_sorder_to_sheet(instance_name)

def promptInstanceName():
    instance_name = ""
    if os.path.exists(f"cached_instance_name"):
        if click.confirm("Use cached instance?"):
            with open(f"cached_instance_name","r") as instance_cache:
                instance_name = instance_cache.readlines()[0]
            print(f"Using cached instance {instance_name}")
    if not instance_name:
        with open(f"cached_instance_name","w") as instance_cache:            
            instance_name = inquirer.select(
                message="Choose instance",
                choices=get_instances(),
                pointer=">",
            ).execute()

            instance_cache.write(instance_name)
    return instance_name

def getIdList(instance):
    mods = []

    with open(f"instances/{instance}/modlist.csv","r") as instance_csv:
        reader = csv.reader(instance_csv)
        for row in reader:
            mods=row
    
    return mods


def generateModList(instance):
    mods = getIdList(instance)

    print("Clearing active mod folder")
    removeFolder("active/mods")
    source_mods  = statter.source_mods_list()
    # print(source_mods)

    missing_mod_list = []

    for mod in mods:
        if mod in source_mods:
            continue
        else:
            print(f"Missing Mod: {mod}")
            missing_mod_list.append(mod)
    
    if missing_mod_list:
        if click.confirm("Missing mods detected. Try to download?"):
            downloadMods(missing_mod_list)
        generateModList(instance)
    else:
        for mod in mods:
            try:
                if mod in source_mods:
                    os.symlink(os.path.abspath(f"source_mods/{mod}"),f"active/mods/{mod}")
                else:
                    print(f"Missing Mod. Download failed?: {mod}")
            except FileExistsError:
                print(f"Duplicate Mod: {mod}")
        if click.confirm("Run RimPy?"):
            os.chdir("../rimpy/")
            os.system("./rimpy")

def setDownloadTime(mods, write_time=None):
    if not write_time:
        write_time = str(time.time() * 1000)

    for mod in mods:
        if not os.path.exists(f"source_mods/{mod}/timeDownloaded"):
            open(f"source_mods/{mod}/timeDownloaded","x")
        with open(f"source_mods/{mod}/timeDownloaded",'w') as dateFile:
            dateFile.write(write_time)

@cli.command("update")
def updateMods():
    modd = statter.mod_metadata()
    toUpdate = []

    for mod in modd:
        if modd[mod]["source"] == "STEAM":
            timeDownloaded = modd[mod]["time_downloaded"]
            timeUpdated = modd[mod]["time_updated"]
            if timeDownloaded < timeUpdated:
                toUpdate.append(mod)

    if toUpdate:
        print(f"The following {len(toUpdate)} mods are out of date:")
        print("\n".join([modd[mod]["name"] for mod in toUpdate]))

        if click.confirm("Download them now?"):
            downloadMods(toUpdate)
    else:
        print("No mods detected out of date.")

@cli.command("stats")
def getModStats():
    # DATA!
    modInfo = statter.loadModInfo()

    options = ["authors","subscribers","size","time","dependencies"]

    choice = inquirer.select(
        message="Get mods by",
        choices=options,
        pointer="-",
    ).execute()

    if choice == "authors":
        statter.get_common_mod_authors(modInfo)
    elif choice == "dependencies":
        modDeps = statter.get_common_mod_dependencies(modInfo)

        modStrings = [f"{dependency}\u0020has {len(modDeps[dependency])} dependents" for dependency in modDeps]

        if click.confirm("Get dependents of specific mod?"):
            mod = inquirer.select(
                message="Choose mod",
                choices=modStrings,
                pointer=">",
            ).execute().split("\u0020")[0]
            print("\n".join(modDeps[mod]))
        else:
            print("\n".join(modStrings))
        

    elif choice == "subscribers":
        data = statter.getModsBy(modInfo,"lifetime_subscriptions",)
        out = ""
        for mod in data:
            out+=f"{mod} has {data[mod]} subscribers \n"
        print(out)
    elif choice == "size":
        data = statter.getModsBy(modInfo,"file_size")
        out = ""
        for mod in data:
            out+=f"{mod} is {humanize.naturalsize(data[mod], binary=True)} \n"
        print(out)
    elif choice == "time":
        data = statter.getModsBy(modInfo,"time_created")
        out = ""
        for mod in data:
            out+=f"{mod} was made at {datetime.fromtimestamp(data[mod]).strftime('%Y-%m-%d %H:%M:%S')}\n"
        print(out)
    return

@cli.command("rentry")
def reentry_manager():
    options = ["Generate","Load"]

    choice = inquirer.select(
            message="Get mods by",
            choices=options,
            pointer=">",
        ).execute()

    if choice == "Load":
        url = click.prompt("Rentry Url?")
        print(rentry.import_rentry(url))
        print(statter.source_mods_list()).values()
    elif choice == "Generate":
        instance_name = promptInstanceName()
        mods = getIdList(instance_name)
        ren = rentry.compile_rentry(mods,statter.mod_metadata())
        rentry.upload(ren)

@cli.command("encode")
def encode():
    ddsEncode()

def ddsEncode():
    os.system("./todds -f BC1 -af BC7 -on -vf -fs -r Textures -t -p source_mods")

@cli.command("sorder")
def ui_sorder():
    load_sorder_to_sheet(promptInstanceName())

def load_sorder_to_sheet(instance_name):
    sorder = statter.load_sort_order(getIdList(instance_name))

    set_sorder(sorder,instance_name)

@cli.command("modd")
def modd():
    statter.mod_metadata()

@cli.command
def whenlastupdated():
    time = click.prompt("Time to set (unix milis)")
    setDownloadTime(statter.source_mods_list(steam_only=True),time)

if __name__ == '__main__':
    cli()
