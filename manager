#!/home/dormierian/Games/rimworld/instance_manager/bin/python

import os, click, humanize, regex, csv
from InquirerPy import inquirer

from datetime import datetime
from sheet_manager import get_modlist_info, get_instances, get_slow_mods, push_to_backend
from helpers import *
import mod_handler, statter, rentry, sorter

os.chdir(os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__))))

@click.group
def cli():
    pass

@cli.command
def modlist():
    instance_name = prompt_instance_name()    

    if click.confirm("Get modlist from sheet?"):
        with open(f"instances/{instance_name}/modlist.csv","w") as instance_csv:
            instance_csv.write(get_modlist_info(instance_name))

    mod_handler.generate_modlist(instance_name)

def prompt_instance_name():
    instance_name = ""
    if os.path.exists(f"cached_instance_name"):
        if click.confirm("Use cached instance?"):
            with open(f"cached_instance_name","r") as instance_cache:
                instance_name = instance_cache.readlines()[0]
            print(f"Using cached instance {instance_name}")
    if not instance_name:
        with open(f"cached_instance_name","w") as instance_cache:            
            instance_name = inquirer.select(
                message="Choose instance",
                choices=get_instances(),
                pointer=">",
            ).execute()

            instance_cache.write(instance_name)
    return instance_name

@cli.command("update")
def cli_update():
    modd = statter.mod_metadata()
    toUpdate = []

    for mod in modd:
        if modd[mod]["source"] == "STEAM":
            timeDownloaded = modd[mod]["time_downloaded"]
            timeUpdated = modd[mod]["time_updated"]
            if timeDownloaded < timeUpdated:
                toUpdate.append(mod)

    if toUpdate:
        print(f"The following {len(toUpdate)} mods are out of date:")
        print("\n".join([modd[mod]["name"] for mod in toUpdate]))

        if click.confirm("Download them now?"):
            mod_handler.downloadMods(toUpdate)
    else:
        print("No mods detected out of date.")

@cli.command("stats")
def cli_mods_stats():
    options = ["authors","subscribers","size","time","dependencies"]

    choice = inquirer.select(
        message="Get mods by",
        choices=options,
        pointer="-",
    ).execute()

    if choice == "authors":
        modd = statter.mod_metadata()

        authors = {}
        for d in modd:
            if modd[d]["author"]:
                # Split authors by commas, strip whitespace, and increment mod count for each author

                for author in [x.lstrip() for x in modd[d]["author"].split(",")]:
                    if author in authors:
                        authors[author].append(d)
                    else:
                        authors[author] = [d]

        # Sort authors by the number of mods they made (descending order)
        authors = {k: v for k, v in sorted(authors.items(), key=lambda item: len(item[1]), reverse=True)}

        # Print the sorted list of authors with mod counts
        modStrings = {f"{author}: {len(authors[author])} mods": author for author in authors}

        author = inquirer.select(
            message="Choose author",
            choices=modStrings,
            pointer=">",
        ).execute()

        author = modStrings[author]

        print("\n".join([modd[mod]["name"] for mod in authors[author]]))

    elif choice == "dependencies":
        modd = statter.mod_metadata(include_ludeon=True)
        deps = {}

        for d in modd:
            if modd[d]["deps"]:
                # Split authors by commas, strip whitespace, and increment mod count for each author
                for dep in modd[d]["deps"]:
                    if dep in deps:
                        deps[dep].append(d)
                    else:
                        deps[dep] = [d]

        # Sort authors by the number of mods they made (descending order)
        deps = {k: v for k, v in sorted(deps.items(), key=lambda item: len(item[1]), reverse=True)}

        modd_by_pid = {modd[x]["pid"]: modd[x] for x in modd}

        # Print the sorted list of authors with mod counts
        modStrings = {f"{modd_by_pid[dep]["name"] if dep in modd_by_pid else dep}: {len(deps[dep])} mods": dep for dep in deps}

        dep = inquirer.select(
            message="Select mod to get dependencies of",
            choices=modStrings,
            pointer=">",
        ).execute()

        dep = modStrings[dep]

        print("\n".join(
            [modd[dep]["name"] for dep in deps[dep]]
        ))
        
    elif choice == "subscribers":
        data = statter.mod_metadata(sort_by="subs")
        out = ""
        for mod in data:
            out+=f"{data[mod]["name"]} has {data[mod]["subs"]} subscribers \n"
        print(out)
    elif choice == "size":
        data = statter.mod_metadata(sort_by="size")
        out = ""
        for mod in data:
            out+=f"{data[mod]["name"]} is {humanize.naturalsize(data[mod]["size"], binary=True)} \n"
        print(out)
    elif choice == "time":
        data = statter.mod_metadata(sort_by="time_created")
        out = ""
        for mod in data:
            out+=f"{data[mod]["name"]} was made at {datetime.fromtimestamp(int(data[mod]["time_created"])).strftime('%Y-%m-%d %H:%M:%S')}\n"
        print(out)
    return

@cli.command("rentry")
def reentry_manager():
    options = ["Generate","Load","Check for Slow Mods"]

    choice = inquirer.select(
            message="Get mods by",
            choices=options,
            pointer=">",
        ).execute()

    if choice == "Load":
        url = click.prompt("Rentry Url?")
        print(rentry.import_rentry(url))
    elif choice == "Generate":
        instance_name = prompt_instance_name()
        mods = mod_handler.get_id_list(instance_name)
        modd = statter.mod_metadata(prune_by=mods,index_by="pid",include_ludeon=True)
        
        i = 0
        for mod in sorter.sorter(mods):
            i+=1
            modd[mod]["sort"] = i

        ren = rentry.compile_rentry(modd)

        rentry.upload(ren)
    elif choice == "Check for Slow Mods":
        url = click.prompt("Rentry Url?")
        modlist = rentry.import_rentry(url)
        slow_mods = get_slow_mods()

        print([x for x in modlist if x in slow_mods])

@cli.command("encode")
def encode():
    mod_handler.dds_encode("source_mods")

@cli.command("modd")
def modd():
    statter.mod_metadata()

@cli.command("sheet_push")
def sheet_push():
    instance_name = prompt_instance_name()
    instance = mod_handler.get_id_list(instance_name)
    modd = statter.mod_metadata(sort_by="time_downloaded") 
    push_to_backend(modd,instance,instance_name)

@cli.command("time")
def whenlastupdated():
    time = click.prompt("Time to set (unix milis)")
    mod_handler.set_download_time(statter.source_mods_list(steam_only=True),time)

@cli.command("sort")
def cli_sort_modlist():
    sorter.sorter(mod_handler.get_id_list(prompt_instance_name()))

@cli.command("add_mods")
def cli_add_mods():
    modd = statter.mod_metadata()
    to_add = []
    print("Write done to stop")
    while True:
        workshop = click.prompt("Steam Workshop URL?").lower()
        if workshop == "done":
            break
        if workshop == "undo":
            print(f"Removed workshop item {to_add[-1]}")
            del to_add[-1]
            continue
        
        id_match = regex.search(r"(?<=\?id=)([0-9]*)",workshop)
        if id_match:
            mod_id = id_match.group()
        else:
            print("Couldn't get id, try again")
            continue

        if mod_id in modd or mod_id in to_add:
            print(f"Mod {mod_id} already downloaded")
            continue
        else:
            print(f"Added mod {mod_id} to list")

        to_add.append(mod_id)
    modd = mod_handler.downloadMods(to_add, regen_mods=True)
    print(modd)
    if click.confirm("Add fresh mods to instance?"):
        instance_name = prompt_instance_name()
        with open(f"instances/{instance_name}/modlist.csv","r") as instance_csv:
            reader = csv.reader(instance_csv)
            for row in reader:
                mods=row
        mods.extend(to_add)
        with open(f"instances/{instance_name}/modlist.csv","w") as instance_csv:
            instance_csv.write(",".join(mods))
        push_to_backend(modd,mods,instance_name)
    mods = []
    
    return mods

def cli_make_instance():
    instance_name = click.prompt("What do you want to name the instance?")
    

if __name__ == '__main__':
    cli()
